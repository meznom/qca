ExactDiagonalization
====================

Installation
------------

Requirements:
 * cmake[1], version 2.6 or greater.
 * Eigen[2], version 2.92.0 (Eigen 3.0-beta2) or greater.
 * Boost[3] to build the unit tests. I'm using version 1.42, but older versions
   will probably work as well.
 * Doxygen[4] to generate the documentation.
 * works with gcc (I am using 4.6) and clang (I am using 3.0)

Build:
 $ mkdir build_dir
 $ cd build_dir
 $ ccmake source_dir
 $ make
To build and run the unit tests:
 $ make check
To only build the tests:
 $ make buildtest
To generate the documentation:
 $ make doc

Example:
In the source_dir:
 $ mkdir Release
 $ cd Release
 $ rm -f CMakeCache.txt && CC=/usr/bin/icc CXX=/usr/bin/icpc cmake -DCMAKE_BUILD_TYPE=Release ..
 $ make
This clears the cmake cache and builds the program with the Intel compiler in
Release mode.

Useful cmake variables:
 * CMAKE_BUILD_TYPE. Can be either Release or Debug. Defaults to Release.
 * EIGEN_INCLUDE_DIR. Where to find Eigen 3. Should be detected automatically.
 * BOOST_INCLUDE_DIR. Where to find Boost. Should be detected automatically.
 * BOOST_LIBRARY. Where to find the boost dynamic library. Should be detected
   automatically.
 * USE_CXX_FLAGS_RELEASE. Compiler flags for Release build type. Reasonable
   defaults should be set automatically, depending on which compiler is used
   (GNU or Intel).
 * USE_CXX_FLAGS_DEBUG. Compiler flags for Debug build type.


Usage
-----

After compilation a file runQca should be in the build_dir. Run
 $ ./runQca --help
to get startet.

For example,
 $ ./runQca -E -m grand2DP -p 1 -t 1 -td 0 -V0 1000 -a 0.01 -b 1000
calculates the energy spectrum for the one plaquet grand-canonical system (with
a dead plaquet) and the given parameters, whereas
 $ ./runQca -P 0,1 -m fixed2DP -p 2 -t 1 -td 0 -V0 1000 \
          -beta 0.01,0.1,1,10 -a 0.01 -b 0.0175,0.025 -Pext 1
computes the polarisation of the first and second plaquet over beta, for the
two plaquet fixed charge system (again, the dead plaquet variant) and for two
different values of b, the inter-plaquet spacing.


Performance
-----------

The performance of gcc 4.6 and clang 3.0 is about the same. For example with gcc 4.6:
$ time nice -19 ./src/runQca -n -m fixed -epc 2 -p 3 -V0 1000 -a 0.01 -b 0.02 \
                             -beta 1 -t 1 -Pext 1 -N 0,1,2 -P 0,1,2 -P2 0,1,2
[...]
real    25m48.757s

And with clang 3.0:
$ time nice -19 ./src/runQca -n -m fixed -epc 2 -p 3 -V0 1000 -a 0.01 -b 0.02 \
                             -beta 1 -t 1 -Pext 1 -N 0,1,2 -P 0,1,2 -P2 0,1,2
[...]
real    25m39.944s

The compilation time with clang is a little bit more than two times faster than
with gcc (~10 seconds instead of ~25 seconds).


Burkhard Ritter (burkhard@ualberta.ca), March 2012


[1] http://www.cmake.org
[2] http://eigen.tuxfamily.org
[3] http://www.boost.org
[4] http://www.doxygen.org
